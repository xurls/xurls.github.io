{"posts":[{"title":"js-取自己","content":"var own=docment.currentScript; ","link":"https://xihale.github.io/js-qu-zi-ji/"},{"title":"c++ vector浅析","content":"注 本文章参考 runoob-vector-浅析 前言 最近遇到一个广搜的题,不管怎么试都会暴 然后我就想到了vector容器 What's vector? 一个容器,无限空间 使用vector 首先,包含他的头文件 #include &lt;vector&gt; using namespace std; 基本函数(都是搬runoob的,有时间再自己梳理) 1.构造函数 vector() //创建一个空vector vector(int nSize) //创建一个vector,元素个数为nSize vector(int nSize,const t&amp; t) //创建一个vector，元素个数为nSize,且值均为t vector(const vector&amp;) //复制构造函数 vector(begin,end) //复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 void push_back(const T&amp; x) //向量尾部增加一个元素X iterator insert(iterator it,const T&amp; x) //向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T&amp; x) //向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last) //向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 iterator erase(iterator it) //删除向量中迭代器指向元素 iterator erase(iterator first,iterator last) //删除向量中[first,last)中元素 void pop_back() //删除向量中最后一个元素 void clear() //清空向量中所有元素 4.遍历函数 reference at(int pos) //返回pos位置元素的引用 reference front() //返回首元素的引用 reference back() //返回尾元素的引用 iterator begin() //返回向量头指针，指向第一个元素 iterator end() //返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin() //反向迭代器，指向最后一个元素 reverse_iterator rend() //反向迭代器，指向第一个元素之前的位置 5.判断函数 bool empty() const //判断向量是否为空，若为空，则向量中无元素 6.大小函数 int size() const //返回向量中元素的个数 int capacity() const //返回当前向量所能容纳的最大元素值 int max_size() const //返回最大可允许的vector元素数量值 7.其他函数 void swap(vector&amp;) //交换两个同类型向量的数据 void assign(int n,const T&amp; x) //设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last) //向量中[first,last)中元素设置成当前向量元素 ##实例 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; int main() { //定义vector vector&lt;int&gt; a; for(int i=10;i&lt;0;i++) a.push_back(i);//在队尾添加值 //排序 sort(a.begin(),a.end()); //输出 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; //使用迭代器访问输出 vector&lt;int&gt; // //iterator it=a.begin(); while(it!=a.end()) { cout&lt;&lt;*it&lt;&lt;' '; it++; } cout&lt;&lt;endl; //很明显,这样会快一点 //清空vector a.clear(); //二维数组的定义就是套一层vector,至于怎么用二维,太麻烦了,暂且不讲 //vector&lt;vector&lt;int&gt;&gt; a; return 0; } ","link":"https://xihale.github.io/cpp-vector/"},{"title":"优雅地交换两个数的值","content":"##前言 这是我在一个晚修时无聊时想到的,我称他为保留数据式交换(没什么技术含量,看看思路即可) 额,写得有点乱,将就看看吧 ##解释 就是把两个数通过特定的方法结合起来,然后我们可以通过其中一个值求出另一个值 ##方法: 1.+ 2.- 3.* 4./ 当然最好的还是 ^ 注意:像 % &amp; | 这样会舍去数据的无法进行交换 ##代码 1.+ //a=1,b=2 a+=b;//a=a+b=1+2=3 b=a-b;//b=a-b=3-2=1 a-=b;//a=a-b=3-1=2 2.- //a=1,b=2 a-=b;//a=a-b=1-2=-1 b+=a;//b=a+b=-1+2=1 a=b-a;//a=b-a=1-(-1)=2 3.* //a=2,b=3 a*=b;//a=a*b=2*3=6 b=a/b;//b=a/b=6/3=2 a/=b;//a=a/b=6/2=3 4./ //a=2.0,b=3.0 这里要用double或float a/=b;//a=a/b=2/3 b*=a;//b=a*b=2/3*3.0=2.0 a=b/a;//a=b/a=2.0/(2/3)=3.0 5.^ 压轴戏(永远不丢失数据) 注:用括号里面的为二进制数 //a=1=(01),b=2=(10) a^=b;//a=a^b=(01)^(10)=11 b=a^b;//b=a^b=(11)^(10)=01 a^=b;//a=a^b=(11)^(01)=10 //此时a=(10)=2,b=(01)=1 这也是我认为的最优的解 原因:1.它在二进制中转换,而其他的都是在十进制的基础完成,理论来说会快一点(因为不考虑进位等) 2.他不会爆 如果两个十进制相加(加减乘除都可能出现这种情况)的话可能会爆出范围,要用高精... ","link":"https://xihale.github.io/cpp_swap/"},{"title":"Github-镜像","content":"1.GitHub 镜像访问 这里提供两个最常用的镜像地址（别登录账号）： https://github.com.cnpmjs.org https://hub.fastgit.org 也就是说上面的镜像就是一个克隆版的Github，你可以访问上面的镜像网站，网站的内容跟Github是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。 2.GitHub文件加速 利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN. https://gh.api.99988866.xyz https://ghproxy.com/ 以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。 3.Github 加速下载 只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！ 地址：http://toolwa.com/github/ 原文:https://blog.rain888.cn/archives/130.html ","link":"https://xihale.github.io/Github-mirror/"}]}