<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xihale.github.io</id>
    <title>xihale</title>
    <updated>2021-05-05T05:02:34.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xihale.github.io"/>
    <link rel="self" href="https://xihale.github.io/atom.xml"/>
    <subtitle>蒹葭苍苍,白露为霜&lt;br&gt;所谓伊人,在水一方</subtitle>
    <logo>https://xihale.github.io/images/avatar.png</logo>
    <icon>https://xihale.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, xihale</rights>
    <entry>
        <title type="html"><![CDATA[优雅地在手机中编程]]></title>
        <id>https://xihale.github.io/codeInMobile/</id>
        <link href="https://xihale.github.io/codeInMobile/">
        </link>
        <updated>2021-05-05T05:00:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="实用">实用</h1>
<h2 id="以管理员运行">以管理员运行</h2>
<pre><code>apt install sudo
</code></pre>
<h2 id="编译环境安装">编译环境安装</h2>
<pre><code>apt install gcc -y
apt install g++ -y
apt install python -y
</code></pre>
<h1 id="美化">美化</h1>
<h2 id="艺术字">艺术字</h2>
<pre><code>apt install figlet
figlet
</code></pre>
<h2 id="装x">装X</h2>
<pre><code>apt install cmatrix
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP-怪盗基德的滑翔翼]]></title>
        <id>https://xihale.github.io/DP-怪盗基德的滑翔翼/</id>
        <link href="https://xihale.github.io/DP-怪盗基德的滑翔翼/">
        </link>
        <updated>2021-04-17T01:18:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="a-hrefhttpybtssoiercn8088problem_showphppid1286进入题目a"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1286">进入题目</a></h2>
<h3 id="思路主体">思路(主体)</h3>
<p>分别向右和向左搜索,找到最大值</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
void dp() //定义函数的方式方便重复调用 
{
	int n,Max_right=0,Max_left=0;
	cin&gt;&gt;n;
	vector&lt;int&gt;m(n+1),fr(n+1,1),fl(n+1,1); //定义容器,一个存序列,一个存序列长度 
	for(int i=0;i&lt;n;i++)
		cin&gt;&gt;m[i]; //输入 
	for(int i=n-1;i&gt;=0;i--) //往右搜 
	{
		for(int j=i+1;j&lt;n;j++)
			if(m[i]&gt;m[j]&amp;&amp;fr[j]&gt;=fr[i]) //找到当前阶段的最长序列 
				fr[i]=fr[j]+1;
		if(fr[i]&gt;fr[Max_right])Max_right=i; //记录最大值的下标 
	}
	for(int i=0;i&lt;n;i++) //往左搜 
	{
		for(int j=i-1;j&gt;=0;j--)
			if(m[i]&gt;m[j]&amp;&amp;fl[j]&gt;=fl[i]) //找到当前阶段的最长序列 
				fl[i]=fl[j]+1;
		if(fl[i]&gt;fl[Max_left])Max_left=i; //记录最大值的下标 
	}
	cout&lt;&lt;(fr[Max_right]&gt;fl[Max_left]?fr[Max_right]:fl[Max_left])&lt;&lt;endl; //这里别忘了换行 
}
int main()
{
	int n;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)
		dp(); //进入函数 
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP-最大上升序列]]></title>
        <id>https://xihale.github.io/DP-最大上升序列/</id>
        <link href="https://xihale.github.io/DP-最大上升序列/">
        </link>
        <updated>2021-04-17T00:48:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="a-hrefhttpybtssoiercn8088problem_showphppid1285-target_blank进入题目a"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1285" target="_blank">进入题目</a></h2>
<h3 id="思路代码主体">思路(代码主体)</h3>
<pre><code class="language-cpp">sum[i]=max(sum[i],sum[j]+m[i])
</code></pre>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
	int n,Max=0;
	cin&gt;&gt;n;
	vector&lt;int&gt;m(n+1),sum(n+1); //定义两个容器,一个用来存序列,一个存序列大小 
	for(int i=0;i&lt;n;i++)
		cin&gt;&gt;m[i]; //输入序列 
	for(int i=n-1;i&gt;=0;i--)
	{
		sum[i]=m[i]; //初始化序列大小为自己本身 
		for(int j=i+1;j&lt;n;j++)
		{
			if(sum[j]+m[i]&gt;sum[i]&amp;&amp;m[i]&lt;m[j]) //判断(j序列和)是否比(i序列和)大并且是不下降的序列 
				sum[i]=sum[j]+m[i];
		}
		if(sum[i]&gt;sum[Max])Max=i;//找最大值的下标 
	}
	cout&lt;&lt;sum[Max];//输出 
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js-取自己]]></title>
        <id>https://xihale.github.io/js-qu-zi-ji/</id>
        <link href="https://xihale.github.io/js-qu-zi-ji/">
        </link>
        <updated>2021-04-10T12:14:56.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">var own=docment.currentScript;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ vector浅析]]></title>
        <id>https://xihale.github.io/cpp-vector/</id>
        <link href="https://xihale.github.io/cpp-vector/">
        </link>
        <updated>2021-04-10T12:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>注 本文章参考 <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank">runoob-vector-浅析</a></p>
<h2 id="前言">前言</h2>
<p>最近遇到一个广搜的题,不管怎么试都会暴<br>
然后我就想到了vector容器</p>
<h2 id="whats-vector">What's vector?</h2>
<p>一个容器,无限空间</p>
<h2 id="使用vector">使用vector</h2>
<p>首先,包含他的头文件</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
using namespace std;
</code></pre>
<h2 id="基本函数都是搬runoob的有时间再自己梳理">基本函数(都是搬runoob的,有时间再自己梳理)</h2>
<h3 id="1构造函数">1.构造函数</h3>
<pre><code class="language-cpp">vector() //创建一个空vector
vector(int nSize) //创建一个vector,元素个数为nSize
vector(int nSize,const t&amp; t) //创建一个vector，元素个数为nSize,且值均为t
vector(const vector&amp;) //复制构造函数
vector(begin,end) //复制[begin,end)区间内另一个数组的元素到vector中
</code></pre>
<h3 id="2增加函数">2.增加函数</h3>
<pre><code class="language-cpp">void push_back(const T&amp; x) //向量尾部增加一个元素X
iterator insert(iterator it,const T&amp; x) //向量中迭代器指向元素前增加一个元素x
iterator insert(iterator it,int n,const T&amp; x) //向量中迭代器指向元素前增加n个相同的元素x
iterator insert(iterator it,const_iterator first,const_iterator last) //向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据
</code></pre>
<h3 id="3删除函数">3.删除函数</h3>
<pre><code class="language-cpp">iterator erase(iterator it) //删除向量中迭代器指向元素
iterator erase(iterator first,iterator last) //删除向量中[first,last)中元素
void pop_back() //删除向量中最后一个元素
void clear() //清空向量中所有元素
</code></pre>
<h3 id="4遍历函数">4.遍历函数</h3>
<pre><code class="language-cpp">reference at(int pos) //返回pos位置元素的引用
reference front() //返回首元素的引用
reference back() //返回尾元素的引用
iterator begin() //返回向量头指针，指向第一个元素
iterator end() //返回向量尾指针，指向向量最后一个元素的下一个位置
reverse_iterator rbegin() //反向迭代器，指向最后一个元素
reverse_iterator rend() //反向迭代器，指向第一个元素之前的位置
</code></pre>
<h3 id="5判断函数">5.判断函数</h3>
<pre><code class="language-cpp">bool empty() const //判断向量是否为空，若为空，则向量中无元素
</code></pre>
<h3 id="6大小函数">6.大小函数</h3>
<pre><code class="language-cpp">int size() const //返回向量中元素的个数
int capacity() const //返回当前向量所能容纳的最大元素值
int max_size() const //返回最大可允许的vector元素数量值
</code></pre>
<h3 id="7其他函数">7.其他函数</h3>
<pre><code class="language-cpp">void swap(vector&amp;) //交换两个同类型向量的数据
void assign(int n,const T&amp; x) //设置向量中前n个元素的值为x
void assign(const_iterator first,const_iterator last) //向量中[first,last)中元素设置成当前向量元素
</code></pre>
<h2 id="实例">实例</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
	//定义vector
	vector&lt;int&gt; a;
	for(int i=10;i&lt;0;i++)
		a.push_back(i);//在队尾添加值
	//排序
	sort(a.begin(),a.end());
	//输出
	for(int i=0;i&lt;10;i++)
		cout&lt;&lt;a[i]&lt;&lt;' ';
	cout&lt;&lt;endl;
	//使用迭代器访问输出
	vector&lt;int&gt; // //iterator it=a.begin();
	while(it!=a.end())
	{
		cout&lt;&lt;*it&lt;&lt;' ';
		it++;
	}
	cout&lt;&lt;endl;
	//很明显,这样会快一点
	//清空vector
	a.clear();
	//二维数组的定义就是套一层vector,至于怎么用二维,太麻烦了,暂且不讲
	//vector&lt;vector&lt;int&gt;&gt; a;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅地交换两个数的值]]></title>
        <id>https://xihale.github.io/cpp_swap/</id>
        <link href="https://xihale.github.io/cpp_swap/">
        </link>
        <updated>2021-04-10T12:12:28.000Z</updated>
        <content type="html"><![CDATA[<p>##前言<br>
这是我在一个晚修时无聊时想到的,我称他为保留数据式交换(没什么技术含量,看看思路即可)<br>
额,写得有点乱,将就看看吧</p>
<p>##解释<br>
就是把两个数通过特定的方法结合起来,然后我们可以通过<font color=blue>其中一个值求出另一个值</font></p>
<p>##方法:<br>
1.+<br>
2.-<br>
3.*<br>
4./<br>
当然最好的还是 ^<br>
注意:像 % &amp; | 这样会舍去数据的无法进行交换</p>
<p>##代码<br>
1.+</p>
<pre><code class="language-cpp">//a=1,b=2
a+=b;//a=a+b=1+2=3
b=a-b;//b=a-b=3-2=1
a-=b;//a=a-b=3-1=2
</code></pre>
<p>2.-</p>
<pre><code class="language-cpp">//a=1,b=2
a-=b;//a=a-b=1-2=-1
b+=a;//b=a+b=-1+2=1
a=b-a;//a=b-a=1-(-1)=2
</code></pre>
<p>3.*</p>
<pre><code class="language-cpp">//a=2,b=3
a*=b;//a=a*b=2*3=6
b=a/b;//b=a/b=6/3=2
a/=b;//a=a/b=6/2=3
</code></pre>
<p>4./</p>
<pre><code class="language-cpp">//a=2.0,b=3.0  这里要用double或float
a/=b;//a=a/b=2/3
b*=a;//b=a*b=2/3*3.0=2.0
a=b/a;//a=b/a=2.0/(2/3)=3.0
</code></pre>
<p>5.^ 压轴戏(永远不丢失数据)<br>
<font color=blue>注:用括号里面的为二进制数</font></p>
<pre><code class="language-cpp">//a=1=(01),b=2=(10)
a^=b;//a=a^b=(01)^(10)=11
b=a^b;//b=a^b=(11)^(10)=01
a^=b;//a=a^b=(11)^(01)=10
//此时a=(10)=2,b=(01)=1
</code></pre>
<p>这也是我认为的最优的解<br>
原因:1.它在二进制中转换,而其他的都是在十进制的基础完成,理论来说会<font color=blue>快</font>一点(因为不考虑进位等)<br>
2.他不会爆 如果两个十进制相加<font color=blue>(加减乘除都可能出现这种情况)</font>的话可能会爆出范围,要用<font color=blue>高精</font>...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github-镜像]]></title>
        <id>https://xihale.github.io/Github-mirror/</id>
        <link href="https://xihale.github.io/Github-mirror/">
        </link>
        <updated>2021-04-10T06:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>1.GitHub 镜像访问<br>
这里提供两个最常用的镜像地址（别登录账号）：<br>
https://github.com.cnpmjs.org<br>
https://hub.fastgit.org<br>
也就是说上面的镜像就是一个克隆版的Github，你可以访问上面的镜像网站，网站的内容跟Github是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。</p>
<p>2.GitHub文件加速<br>
利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.<br>
https://gh.api.99988866.xyz<br>
https://ghproxy.com/<br>
以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。</p>
<p>3.Github 加速下载<br>
只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！<br>
地址：http://toolwa.com/github/</p>
<p>原文:https://blog.rain888.cn/archives/130.html</p>
]]></content>
    </entry>
</feed>