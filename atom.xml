<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xihale.github.io</id>
    <title>xihale</title>
    <updated>2021-04-10T12:16:59.832Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xihale.github.io"/>
    <link rel="self" href="https://xihale.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xihale.github.io/images/avatar.png</logo>
    <icon>https://xihale.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, xihale</rights>
    <entry>
        <title type="html"><![CDATA[js-取自己]]></title>
        <id>https://xihale.github.io/js-qu-zi-ji/</id>
        <link href="https://xihale.github.io/js-qu-zi-ji/">
        </link>
        <updated>2021-04-10T12:14:56.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">var own=docment.currentScript;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ vector浅析]]></title>
        <id>https://xihale.github.io/cpp-vector/</id>
        <link href="https://xihale.github.io/cpp-vector/">
        </link>
        <updated>2021-04-10T12:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>注:本文章参考 https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html<br>
##前言:<br>
最近遇到一个广搜的题,不管怎么试都会暴<br>
然后我就想到了vector容器</p>
<p>##What's vector?<br>
一个无限空间的链表程序集<br>
既然是链表,那么每层所耗的空间就会是原来的2~3倍(<em>next或</em>last)而且访问速度会变慢一点<br>
但是他还是挺好用</p>
<p>##使用vector<br>
首先,包含他的头文件</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
using namespace std;
</code></pre>
<p>##基本函数(都是搬runoob的,有时间在自己梳理)<br>
###1.构造函数<br>
vector():创建一个空vector<br>
vector(int nSize):创建一个vector,元素个数为nSize<br>
vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>
vector(const vector&amp;):复制构造函数<br>
vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中<br>
###2.增加函数<br>
void push_back(const T&amp; x):向量尾部增加一个元素X<br>
iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>
iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>
iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据<br>
###3.删除函数<br>
iterator erase(iterator it):删除向量中迭代器指向元素<br>
iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>
void pop_back():删除向量中最后一个元素<br>
void clear():清空向量中所有元素<br>
###4.遍历函数<br>
reference at(int pos):返回pos位置元素的引用<br>
reference front():返回首元素的引用<br>
reference back():返回尾元素的引用<br>
iterator begin():返回向量头指针，指向第一个元素<br>
iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>
reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>
reverse_iterator rend():反向迭代器，指向第一个元素之前的位置<br>
###5.判断函数<br>
bool empty() const:判断向量是否为空，若为空，则向量中无元素<br>
###6.大小函数<br>
int size() const:返回向量中元素的个数<br>
int capacity() const:返回当前向量所能容纳的最大元素值<br>
int max_size() const:返回最大可允许的vector元素数量值<br>
###7.其他函数<br>
void swap(vector&amp;):交换两个同类型向量的数据<br>
void assign(int n,const T&amp; x):设置向量中前n个元素的值为x<br>
void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
<p>##实例</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
	//定义vector
	vector&lt;int&gt; a;
	for(int i=10;i&lt;0;i++)
		a.push_back(i);//在队尾添加值
	//排序
	sort(a.begin(),a.end());
	//输出
	for(int i=0;i&lt;10;i++)
		cout&lt;&lt;a[i]&lt;&lt;' ';
	cout&lt;&lt;endl;
	//使用迭代器访问输出
	vector&lt;int&gt;::iterator it=a.begin();
	while(it!=a.end())
	{
		cout&lt;&lt;*it&lt;&lt;' ';
		it++;
	}
	cout&lt;&lt;endl;
	//很明显,这样会快一点
	//清空vector
	a.clear();
	//二维数组的定义就是套一层vector,至于怎么用二维,太麻烦了,暂且不讲
	//vector&lt;vector&lt;int&gt;&gt; a;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅地交换两个数的值]]></title>
        <id>https://xihale.github.io/cpp_swap/</id>
        <link href="https://xihale.github.io/cpp_swap/">
        </link>
        <updated>2021-04-10T12:12:28.000Z</updated>
        <content type="html"><![CDATA[<p>##前言<br>
这是我在一个晚修时无聊时想到的,我称他为保留数据式交换(没什么技术含量,看看思路即可)<br>
额,写得有点乱,将就看看吧</p>
<p>##解释<br>
就是把两个数通过特定的方法结合起来,然后我们可以通过<font color=blue>其中一个值求出另一个值</font></p>
<p>##方法:<br>
1.+<br>
2.-<br>
3.*<br>
4./<br>
当然最好的还是 ^<br>
注意:像 % &amp; | 这样会舍去数据的无法进行交换</p>
<p>##代码<br>
1.+</p>
<pre><code class="language-cpp">//a=1,b=2
a+=b;//a=a+b=1+2=3
b=a-b;//b=a-b=3-2=1
a-=b;//a=a-b=3-1=2
</code></pre>
<p>2.-</p>
<pre><code class="language-cpp">//a=1,b=2
a-=b;//a=a-b=1-2=-1
b+=a;//b=a+b=-1+2=1
a=b-a;//a=b-a=1-(-1)=2
</code></pre>
<p>3.*</p>
<pre><code class="language-cpp">//a=2,b=3
a*=b;//a=a*b=2*3=6
b=a/b;//b=a/b=6/3=2
a/=b;//a=a/b=6/2=3
</code></pre>
<p>4./</p>
<pre><code class="language-cpp">//a=2.0,b=3.0  这里要用double或float
a/=b;//a=a/b=2/3
b*=a;//b=a*b=2/3*3.0=2.0
a=b/a;//a=b/a=2.0/(2/3)=3.0
</code></pre>
<p>5.^ 压轴戏(永远不丢失数据)<br>
<font color=blue>注:用括号里面的为二进制数</font></p>
<pre><code class="language-cpp">//a=1=(01),b=2=(10)
a^=b;//a=a^b=(01)^(10)=11
b=a^b;//b=a^b=(11)^(10)=01
a^=b;//a=a^b=(11)^(01)=10
//此时a=(10)=2,b=(01)=1
</code></pre>
<p>这也是我认为的最优的解<br>
原因:1.它在二进制中转换,而其他的都是在十进制的基础完成,理论来说会<font color=blue>快</font>一点(因为不考虑进位等)<br>
2.他不会爆 如果两个十进制相加<font color=blue>(加减乘除都可能出现这种情况)</font>的话可能会爆出范围,要用<font color=blue>高精</font>...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github-镜像]]></title>
        <id>https://xihale.github.io/Github-mirror/</id>
        <link href="https://xihale.github.io/Github-mirror/">
        </link>
        <updated>2021-04-10T06:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>1.GitHub 镜像访问<br>
这里提供两个最常用的镜像地址（别登录账号）：<br>
https://github.com.cnpmjs.org<br>
https://hub.fastgit.org<br>
也就是说上面的镜像就是一个克隆版的Github，你可以访问上面的镜像网站，网站的内容跟Github是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。</p>
<p>2.GitHub文件加速<br>
利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.<br>
https://gh.api.99988866.xyz<br>
https://ghproxy.com/<br>
以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。</p>
<p>3.Github 加速下载<br>
只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！<br>
地址：http://toolwa.com/github/</p>
<p>原文:https://blog.rain888.cn/archives/130.html</p>
]]></content>
    </entry>
</feed>